from typing import Callable
import math
from .message_template import MessageTemplate
from .exploit_storage import ExploitStorage

# --- EVALUATION RESULT ---
class ExploitEvaluation:
    def __init__(self, active: bool, severity: float, confidence: float):
        self.active = active
        self.severity = severity
        self.confidence = confidence

class ExploitEvaluator:
    def __init__(self, gto_value: float, is_too_high: bool = False, hands: int = 0, value: int = 0, save_callback: Callable[[str, int, int], None] = None):
        self.gto_value = gto_value
        self.is_too_high = is_too_high
        self.hands: int = hands
        self.value: int = value
        self.save_callback = save_callback
        self.evaluation = self.evaluate()
    
    @property
    def rate(self) -> float:
        return self.value / self.hands if self.hands > 0 else 0.0

    def record(self, hands_increment: int, value_increment: int, exploit_id: str = None):
        self.hands += hands_increment
        self.value += value_increment

        if self.hands % 5 == 0 and self.save_callback and exploit_id:
            self.save_callback(exploit_id, self.hands, self.value)

        self.evaluation = self.evaluate()
    
    def is_active(self) -> bool:
        return self.evaluation.active

    def evaluate(self) -> ExploitEvaluation:
        if self.hands < 5: 
            return ExploitEvaluation(False, 0.0, 0.0)

        actual_rate = self.rate
        
        # Calculate absolute difference (e.g., 0.10)
        absolute_diff = actual_rate - self.gto_value
        
        # Calculate relative difference (e.g., 0.10 / 0.40 = 0.25 = 25%)
        # Add small protection against division by zero
        safe_gto = self.gto_value if self.gto_value > 0.01 else 0.01
        relative_diff = abs(absolute_diff / safe_gto)

        # Relative deviation threshold: assume we allow 20% deviation from original value before alerting
        base_tolerance_ratio = 0.20 
        
        # Adjust for sample size (threshold increases as hands decrease)
        sample_penalty = 0.5 * math.exp(-self.hands / 30)
        current_threshold_ratio = base_tolerance_ratio + sample_penalty

        is_exploit = False

        # Check direction
        if (actual_rate > self.gto_value and self.is_too_high) or (actual_rate < self.gto_value and not self.is_too_high):
            is_exploit = relative_diff > current_threshold_ratio

        if not is_exploit:
            return ExploitEvaluation(False, 0.0, 0.0)

        # Calculate severity: if deviated by 50% relatively (e.g., 30% instead of 20%), it's insignificant (0.0)
        # 0.20 is the threshold, 0.60 deviation is max severity
        severity = min(1.0, (relative_diff - base_tolerance_ratio) / 0.40)

        confidence = min(1.0, self.hands / 50)

        return ExploitEvaluation(True, severity, confidence)
    
class ExploitMessageRenderer:
    def render(self, template: MessageTemplate, level: int, context: dict) -> str:
        raw = template.get(level)
        if not raw:
            return ""
        
        # context variables: player_val, gto, diff_absolute, rel_diff, severity
        return raw.format(**context)

class ExploitDefinition:
    def __init__(self, id: str, exploit_type: str, street: int, main_player_action: str, is_spot_fits: Callable, evaluator: ExploitEvaluator, message_template: MessageTemplate, update_stats: Callable):
        self.id = id

        self.exploit_type = exploit_type
        self.street = street
        self.main_player_action = main_player_action
        self.is_spot_fits = is_spot_fits
        self.evaluator = evaluator
        # Set save callback for evaluator
        self.evaluator.save_callback = ExploitStorage.save
        self.template = message_template
        self.update_stats = update_stats
        self.renderer = ExploitMessageRenderer()
        
        # Load from file if exists
        ExploitStorage.load(self)

    def get_message(self, level: int) -> str:
        player_pct = self.evaluator.rate * 100
        gto_pct = self.evaluator.gto_value * 100
        
        # Calculate relative change percentage
        # Example: GTO=40, Player=30 -> Diff=10 -> Relative=25%
        if gto_pct > 0:
            relative_change = (abs(player_pct - gto_pct) / gto_pct) * 100
        else:
            relative_change = 0

        context = {
            "player_val": player_pct,
            "gto": gto_pct,
            "diff_absolute": abs(player_pct - gto_pct),
            "rel_diff": relative_change,
            "severity": self.evaluator.evaluation.severity
        }

        return self.renderer.render(self.template, level, context)
    
    def save_to_file(self):
        ExploitStorage.save(self.id, self.evaluator.hands, self.evaluator.value)