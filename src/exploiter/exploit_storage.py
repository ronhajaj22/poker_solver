import json
import os
from typing import TYPE_CHECKING
from AppUtils.files_utils import get_exploits_filepath

if TYPE_CHECKING:
    from .exploit import ExploitDefinition

class ExploitStorage:
    @staticmethod
    def load(exploit_def: 'ExploitDefinition'):
        path = get_exploits_filepath()
        if not os.path.exists(path):
            return
        
        try:
            with open(path, 'r') as f:
                all_data = json.load(f)
                if isinstance(all_data, dict) and exploit_def.id in all_data:
                    data = all_data[exploit_def.id]
                    if 'hands' in data and 'value' in data:
                        exploit_def.evaluator.hands = data['hands']
                        exploit_def.evaluator.value = data['value']
                        exploit_def.evaluator.evaluation = exploit_def.evaluator.evaluate()
        except (json.JSONDecodeError, IOError) as e:
            print(f"Error loading {exploit_def.id}: {e}")

    @staticmethod
    def save(exploit_id, hands, value):
        path = get_exploits_filepath()
        
        # Load existing data if file exists (dictionary of all exploits)
        all_data = {}
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    content = f.read().strip()
                    if content:  # Only parse if file is not empty
                        all_data = json.loads(content)
                        if not isinstance(all_data, dict):
                            all_data = {}
            except (json.JSONDecodeError, IOError):
                all_data = {}
        
        # Create or update this specific exploit's data, preserve others
        exploit_data = all_data.get(exploit_id, {})
        exploit_data['id'] = exploit_id
        exploit_data['hands'] = hands
        exploit_data['value'] = value
        all_data[exploit_id] = exploit_data
        
        with open(path, 'w') as f:
            json.dump(all_data, f)

