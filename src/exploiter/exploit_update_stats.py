import AppUtils.StringUtils as strings
from hands_classifier.hands_river_category_classifier import HAND_CLASS_TO_IDX
from AppUtils.constants import FLOP, TURN, RIVER

def over_fold_update_stats(player, action, num_raises, hand_strength=0.0):
    if num_raises == 1:
        if action == strings.FOLD:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def over_call_update_stats(player, action, num_raises, hand_strength=0.0):
    if num_raises == 1:
        if action == strings.CALL:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def raise_range_is_too_strong_update_stats(player, action, num_raises, hand_type):
    if action == strings.RAISE and num_raises == 1:
        if HAND_CLASS_TO_IDX[hand_type] <= 6: # over-pair or better
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def c_bet_freq_too_high_update_stats(player, action, num_raises, hand_strength=0.0):
    if player.is_pre_flop_agressor and num_raises == 0:
        if action == strings.RAISE:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def check_back_range_is_too_weak_update_stats(player, action, num_raises, hand_type):
    if num_raises == 0 and player.is_pre_flop_agressor and action == strings.CHECK:
        if hand_type == "HIGH_CARD":
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def turn_shut_down_after_barrel_update_stats(player, action, num_raises):
    if num_raises == 0 and player.is_pre_flop_agressor and player.is_flop_agressor: 
        if action == strings.CHECK:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def fold_to_turn_barrel_too_high_update_stats(player, game_actions, num_raises):
    if num_raises == 1 and not player.is_flop_agressor and game_actions[FLOP].includes(strings.RAISE): # TODO - this is not exactly correct - we need to check if villain bet the flop
        if action == strings.FOLD:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def turn_fold_to_big_bet_update_stats(player, action, num_raises, last_bet_size, hand_strength=0.0):
    if num_raises == 1 and last_bet_size > 0.6:
        if action == strings.FOLD:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def river_bet_range_is_too_weak(player, action, num_raises, hand_type):
    if num_raises == 0 and player.hand_strength > 0.5:
        if action == strings.RAISE:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def river_bet_range_is_too_strong(player, action, num_raises, hand_type):
    if action == strings.RAISE:
        if hand_type == "VALUE":
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def river_over_call_update_stats(player, action, num_raises, hand_type):
    if num_raises == 1:
        if action == strings.CALL:
            return (1,1)
        else:
            return (1,0)
    return (0,0)

def river_bet_size_too_correlated_update_stats(player, action, num_raises, last_bet_size, hand_strength=0.0):
    pass

def river_over_fold_update_stats(player, action, num_raises, hand_strength=0.0):
    if num_raises == 1 and action == strings.FOLD:
        return (1,1)
    else:
        return (1,0)
    return (0,0)    